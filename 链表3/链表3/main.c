#define _CRT_SECURE_NO_WARNINGS 1
#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<malloc.h>
#include<stdlib.h>
#include<assert.h>
typedef struct Node
{
	int data;
	struct Node *next;
}LNode;
LNode *creat(int n){
	LNode *head, *node, *tail;//定义头节点，普通节点，尾部节点；
	head = (LNode*)malloc(sizeof(LNode));//开辟分配地址
	head->next = NULL;
	tail = head;         //若果是空链表则头节点==尾节点
	for (int i = 0; i <n; i++) {
		node = (LNode*)malloc(sizeof(LNode));
		scanf("%d", &node->data);
		node->next = NULL;
		tail->next = node;
		tail = node;
	}
	tail->next = NULL;//结束创建
	return head;
}

void Find1(LNode *head, int pos)//：按位值查找
{
	LNode *p = head;
	int i = 1;
	while (p != NULL&&i != pos)
	{
		p = p->next;
		i++;
	}
	if (i == pos)
		return p;
	else
		return NULL;
}
void Find2(LNode *head, int X)
{
	LNode *p = head;
	while (p != NULL&&p->data != X)
	{
		p = p->next;
	}
	return p;
}
void Insert(LNode *head, int i, int X)//:在第i个元素前插入X
{
	LNode *s;
	if (i == 1)//:若在head前插入
	{
		s = (LNode*)malloc(sizeof(LNode));
		s->data = X;
		s->next = head;
		return s;
	}
	LNode *p = head;
	int a = 1;
	while (p != NULL&&a < i)
	{
		p = p->next;
		a++;
	}
	s = (LNode*)malloc(sizeof(LNode));
	s->data = X;
	s->next = p->next;
	p->next = s;
	return head;
}
void Delete(LNode *head, int i)//:删除链表的第i个节点
{
	LNode *s;
	if (i == 1)
	{
		s = head;
		if (head != NULL)
		{
			head = head->next;
		}
		else
			return NULL;
		free(s);
		return head;
	}
	Find1(head, i - 1);
	LNode *p = head;
	int a = 1;
	while (p != NULL&&a < i)
	{
		p = p->next;
		a++;
	}
	if (p == NULL)
	{
		printf("第i个节点不存在");
		return NULL;
	}
	else if (p->next == NULL)
	{
		printf("不存在");
		return NULL;
	}
	else
		s = p->next;
	p->next = s->next;
	free(s);
	return head;
}

void show(LNode *head)//链表的输出
{
	LNode *h;
	h = head->next;
	while (h != NULL)
	{
		if (h->next == NULL)
			printf("%d", h->data);
		else
			printf("%d", h->data);
		h = h->next;
	}
}
int main()
{
	int n;
	scanf("%d", &n);
	LNode *head;
	head = creat(n);
	Delete(head, 2);
	Insert(head, 2, 1);
	show(head);
	return 0;
}
